<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Week 3: Morphology</title>
    <meta charset="utf-8" />
    <meta name="author" content="Quartz Colvin (they/them)" />
    <meta name="date" content="2025-09-18" />
    <script src="libs/header-attrs-2.29/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/rutgers.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/rutgers-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Week 3: Morphology
]
.subtitle[
## Recitation for LING 201:02
]
.author[
### Quartz Colvin (they/them)
]
.institute[
### Rutgers University
]
.date[
### 2025-09-18
]

---


class: middle, center

# Terminology 

---

# Terminology 

- compounding

- affixation 

- reduplication 

- alternation 

- suppletion 

- zero-derivation 

- acronym 

- blend 

- clipping 

- reanalysis

---

class: middle, center

# Identifying word-formation processes 

---

# Identifying word-formation processes

- Identify the morphological processes involved in the following words. 

- Some will exhibit one process, some will exhibit multiple. 

*(Note: Say the words out loud to hear differences in sound.)*

.pull-left[
1. feed → fed

2. leaf →  leaves

3. peace →  peaceful

4. foot, ball → football 

5. good →  best
]

.pull-right[
6. chair, woman →  chairwomen

7. back, pack →  backpacks

8. like →  like-liked

9. go →  underwent
]


---

# Order of affixation 

- consider the words *unbelievable* and *renewable*. 

  - How many morphemes do they each have? 
  
  - What's the root? Are there prefixes or suffixes? 

--

- Now imagine you start with the root and then add affixes until you get the full word. Do you start with the prefix or suffix? Which do you add first?

  - Is it *un* + *believable* **or** *unbelieve* + *able*? Why? 
  
  - Is it *renew* + *able* **or** *re* + *newable*? Why?

---

# Order of affixation 

- Even though *unbelievable* and *renewable* both have three morphemes (prefix-root-suffix), there seems to be something different about the order in which the morphemes are added to the root!

--

In *un*-**believ**-*able* you add the suffix first and the prefix second
  
--

  1. Does adding an affix make a real word? **believ**-*able* is a real word, but \**un*-**believe** is not
    
    - What does the word mean? *unbelievable* means *not believable*, not *able to be unbelieved* 

--

In *re*-**new**-*able*, you add the suffix first and the prefix second

--

   1. Does adding an affix make a real word? *re*-**new** is a real word, but \***new**-*able* is not
  
  - What does the word mean? *renewable* means *able to be renewed*, not *newable again*

---

# Order of affixation 

This suggest that the **order of affixation**- the order in which you add affixes to a root- plays a role in the morphology of a word!

--

- different words have different orders of affixation 

- order of affixation is part of our mental grammar (what we know about a word as speakers)

--

- we can test a word's order of affixation by:

  - adding an affix and seeing if it makes a real word

--

  - trying to understand what the word means. if your definition involves some smaller combination of the root and an affix, it suggests that the affix is added first 

--

***neither of these tests works 100% of the time, so you should try a combination of them!***

---

class: middle, center 

# Morphological trees!

---

# Morphological trees

## Hierarchical structure

- order of affixation is somehow connected to the *meaning* of a word

- the fact that we can't add affixes in any order suggests that words have a **hierarchical structure**

--

- we can visualize this structure with a **tree diagram**!

---

# Hierarchical structure

We can visualize this structue with a tree diagram...

- we **start at the bottom** with the root and **build upward**, adding affixes until we get to the full word at the top

--

- an alternative notation is **labeled bracketing**, which is more compact but perhaps less intuitive

--

  - [&lt;sub&gt;Adj&lt;/sub&gt; un [&lt;sub&gt;V&lt;/sub&gt; [&lt;sub&gt;V&lt;/sub&gt; believe ] able ]]

  - [&lt;sub&gt;Adj&lt;/sub&gt; [&lt;sub&gt;V&lt;/sub&gt; re [&lt;sub&gt;Adj&lt;/sub&gt; new ]] able ]
  
---

# Hierarchical structure 

### Notation comparison

.pull-left[

- [&lt;sub&gt;Adj&lt;/sub&gt; un [&lt;sub&gt;V&lt;/sub&gt; [&lt;sub&gt;V&lt;/sub&gt; believe ] able ]]

&lt;img src="./images/unbelievable.png" width="100%" height="100%" /&gt;
]

--

.pull-right[

- [&lt;sub&gt;Adj&lt;/sub&gt; [&lt;sub&gt;V&lt;/sub&gt; re [&lt;sub&gt;Adj&lt;/sub&gt; new ]] able ]

&lt;img src="./images/renewable.png" width="95%" height="95%" /&gt;
]

---

class: middle, center

# Trees!

---

# Trees 

**How to draw a morphological tree:**

1. identify the word's morphemes and write them out separately in one row *(leave plenty of space above them!)*

--

2. identify the root(s) and label their part of speech

--

3. look at the morphemes immediately before and after the root. Which one is added first? Draw lines upward connecting them, and label the new word's part of speech

--

4. this new word becomes the base you'll keep building off of. Repeat step 3 using this new base instead of the root, and continue until you have no unconnected morphemes left


---

## How to draw a morphological tree:

.pull-left[
1. identify morphemes 

  - write them in a row

2. identify root(s) 
  
  - label parts of speech

3. morphemes immediately beside the root: 

  - Which one is added first? 
    
    - Draw lines upward connecting them
    
    - label new word's part of speech
]

--

.pull-right[

**4.** the result of **Step 3** is the new base word for the next "round"

  - repeat **step 3** until all morphemes are connected

&lt;img src="./images/dehumidifier.png" width="90%" height="90%" /&gt;
]


---

class: middle, center

# Practice!

---

# Practice!

**Draw a tree or give bracket labeling for the following words:**

.pull-left[
1. disappearance 

2. silliness 

3. unthinkable 

4. overgeneralization 

5. internationalism
]


.pull-right[

***Reminders:***

- start at the root and move outward/upward

- remember to mark the part of speech at every step/node

- of adding an affix makes something that isn't a word, try adding a different affix instead

- if adding an affix makes something that seems unrelated to the overall word's meaning, try adding a different affix instead
]

---

# Undoable

- Consider the word *undoable*. What does it mean? 

- Does it mean something different if it's *undo* + *able* vs. *un* + *doable*? How would you define each word? 


---

class: center, middle

# Morphological ambiguity 

---

# Morphological ambiguity 

- this word (***undoable***) is an example of a word with an ambiguous structure 

--

- **structural ambiguity:** depending on the structure you assign it, it has a different meaning 

--

- this suggests that tree drawing isn't just a game: the **meaning** of words is directly affected by their morphological structure!

--

- without knowing the structure, we wouldn't know how to put together the meanings of a word's different morphemes to create the full word

--

.pull-left[
&lt;img src="./images/undoable.png" width="90%" height="90%" /&gt;
]

.pull-right[
&lt;img src="./images/undoable2.png" width="90%" height="90%" /&gt;
]

---

class: middle, center

# Practice!

---

# Practice: ambiguous structures

## Are the following words ambiguous? 

**If yes,** provide labeled bracketings for both readings and explain what each reaching means. 

**If no,** explain why not. 

--

1. immeasurable 

2. unwrappable

3. unbearable


---

# Coming up 

.pull-left[

### Reading 

- *Lang. Files* Ch. 4.3-4.5 if you haven't yet!

- Carnie, Ch. 2

### Homework 

- HW1 due **Sept 21**

]

--

.pull-left[

## Next week!

- **no in-person recitation!** I will assign something to work on remotely (I'll send an announcement when it's ready)

- my office hour will only be on Zoom this time

]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
  "highlightStyle": "github",
  "highlightLines": true,
  "countIncrementalSlides": false,
  "bibliography": "bibliography.bib"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
